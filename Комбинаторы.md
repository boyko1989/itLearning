# Комбинаторы
Объединяют несколько простых селекторов в один сложный
[Специфичность](Специфичность.md): (0, 0, 1)
[Статья](https://coderlessons.com/articles/veb-razrabotka-articles/css-selektory-kombinatory)

```html
<header>
    <nav>
		<div class="nav-menu">
			<div class="logo">
				<a href="/">
					<img src="#" alt="">
				</a>
			</div>
			<ul class="list-menu">
				<li></li>
				<li></li>
				<li></li>
			</ul>
		</div>
    </nav>
</header>
<body>
    <saidbar>
        <h2>Боковая</h2>
    </saidbar>
    <main>
        <h></h1>
		  <form>
		  	<fieldset>
				<legend>Tickets and Add-ons</legend>
				<p>
					<label for="quantity">Number of Tickets</label> 
					<span class="help">Limit 8</span>
					<input type="number" value="1" name="quantity" id="quantity" step="1" min="1" max="8">
				</p>
				<p>
					<label for="quantity">Dinner Packages</label> 
					<span class="help">Serves 2</span>
					<input type="number" value="1" name="quantity" id="quantity" step="1" min="1" max="8">
				</p>
		  </form>
    </main>
</body>
```

- *Комбинатор потомков* (пробел): указывает, что целевой элемент (второй указанный) — это потомок первоначально записанного элемента.
	Например:
```css
.nav-menu li {
...		
}
```
Этот селектор обращается ко всем потомкам, поэтому если нужно обратиться только к следующему, то следует использовать следующий вид комбинаторов.

- *Детский комбинатор* (>): нацеливается на элемент, который является  прямым потомком первоналчально указанного элемента. 
Например:
```css
.nav-menu > .logo {
...
}
```
- *Кобинатор соседнего брата* (+): нацеливается наэлементы указанные вторыми, которым непосредственно предшествуют первоначально указанные.
Например:
```css
.logo + .list-menu {
...
}
```

> В качестве подпримера

```css
 * + fieldset {
margin: 5em 0;
}
```
*(про [fieldset]( fieldset))*
Универсальный селектор и селектор типа позволяют не бемпокоиться о том, является ли предыдущий элемент другим ```fieldset p```


- *Генеральный брат и сестра комбинатор* (~): может выбирать элементы, которые имеют одного и того же родителя, не считая их смежными. 
Это означает, что мы можем стилизовать элемент родного брата, который не соседствует с другим.
```css
 label ~ input {
display: block;
}
```

Этими "родственниками" нужно пользоваться, когда не хватает полного контроля над разметкой. В противном случае лучше использовать классы — они дают меньше побочных эффектов, особенно в большом файле стилей.